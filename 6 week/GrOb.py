"""Штаб гражданской обороны Тридесятой области
 решил обновить план спасения на случай ядерной атаки.
 Известно, что все n селений Тридесятой области
 находятся вдоль одной прямой дороги. Вдоль дороги
  также расположены m бомбоубежищ, в которых жители
   селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило
 как можно эффективнее, необходимо для каждого селения
 определить ближайшее к нему бомбоубежище.

Формат ввода

В первой строке вводится число n - количество селений
(1 <= n <= 100000). Вторая строка содержит n различных
целых чисел, i-е из этих чисел задает расстояние
 от начала дороги до i-го селения. В третьей строке
  входных данных задается число m - количество бомбоубежищ
   (1 <= m <= 100000). Четвертая строка содержит m
   различных целых чисел, i-е из этих чисел задает
   расстояние от начала дороги до i-го бомбоубежища.
    Все расстояния положительны и не превышают 10⁹.
     Селение и убежище могут располагаться в одной точке.

Формат вывода

Выведите n чисел - для каждого селения выведите номер
 ближайшего к нему бомбоубежища. Бомбоубежища пронумерованы
 от 1 до m в том порядке, в котором они заданы во входных
  данных.

Указание

Создайте список кортежей из пар
 (позиция селения, его номер в исходном списке)
 , а также аналогичный список для бомбоубежищ.
  Отсортируйте эти списки.

Перебирайте селения в порядке возрастания.

Для селения ближайшими могут быть два
соседних бомбоубежища, среди них надо выбрать ближайшее.
 При переходе к следующему селению не обязательно
  искать ближайшее бомбоубежище с самого начала.
   Его можно искать начиная с позиции,
   найденной для предыдущего города.

Для хранения ответа используйте список,
 где индекс будет номером селения, а по этому
 индексу будет запоминаться номер бомбоубежища."""

townN = int(input())
townS = list(map(int, input().split()))
vaultN = int(input())
vaultS = list(map(int, input().split()))


townTuple = []
# print("townTuple = ", townTuple)
for i in range(townN):
    townTuple.append((townS[i], i + 1))

# print("townTuple = ", townTuple)

vaultTuple = []
for i in range(vaultN):
    vaultTuple.append((vaultS[i], i + 1))
# print("vaultTuple = ", vaultTuple)

vaultTupleS = sorted(vaultTuple)
townTupleS = sorted(townTuple)
# print("townTupleS = ", townTupleS)
# print("vaultTupleS = ", vaultTupleS)

currentVault = 0
answer = []
a = 0
b = 0

for x in range(len(townTupleS)):
    radius = 10e9

    # print("x=", x)
    for y in range(currentVault, len(vaultTupleS)):
        # print("y=", y)

        if abs(vaultTupleS[y][0] - townTupleS[x][0]) <= radius:
            radius = abs(vaultTupleS[y][0] - townTupleS[x][0])
            a = vaultTupleS[y][1]
            # number of vault
            b = townTupleS[x][1]
            # number of town
            currentVault = y
            # print("a=", a)
        else:
            break
    # print("bfinal=", a)
    # print("afinal=", a)
    answer.append([b, a])

answer.sort()

ans = []

for z in range(len(answer)):
    ans.append(answer[z][1])
print(*ans)
